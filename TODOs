LA SEMAINE 3:
- définition des structures de base:
      noeud - une pièce dans un labirynt, on connait son id, ses voisins, son contenu, le temps de la dernière mise à jour,
              son état (visité ou vu mais pas encore visité)
              
              TODO : Si on ajoute des voisins à un noued A, il faut aussi ajouter A dans la liste des voisins de ses voisins 
                     (la rélation "être voisin" étant symmétrique)  ... et réfléchir si ceci est pertinent ou pas (à priori oui, 
                     ça nous coûte plus de temps quand on crée le graphe, mais on a plus d'informations ce qui peut faciliter 
                     des parcours)
              
              Doit être sérialisable
      graphe - une liste de noeuds. La classe contient aussi toutes les fonctions liées à la manipulation du graphe, 
               ainsi que les algorithmes de graphe (des parcours, fusion de deux graphes etc.)
               
               TODO : gérer l'histoire des pointeurs aux voisins dans la fonction de fusion des graphes
                      (je ne me rappelle plus si on y fait des clones ou pas, il faut y revenir et gérer ça)
               
- parcours monoagent: 
      solution proposée : l'agent avance dans un graphe dès qu'il peut. Une fois tous les noeuds accessibles sont visités, 
                          il lance le parcours en largeur pour trouver le noeud le plus proche qu'il a vu mais pas encore visité.
                          
                          Une fois un tel noeud n'existe pas, l'agent a tout visité, sa carte est complète. 
                          
                          TODO : enlever ce behaviour une fois la carte est créée et ajouter un nouveau behaviour pour 
                                 le comportement d'agent après
                                 
---------------------------------------------------------------------------------------------------------------------------------
LA SEMAINE 4 :

- parcours multi-agent:
      - partage des cartes - cf. TODO plus haut, sur l'histoire des pointeurs aux voisins
      
      TODO : dans un behaviour BFSWalkBehaviour (ou à la limite dans tous les behaviours de parcours qu'on créera en future),
             si on veut se déplacer vers une case, il faut d'abord vérifier si elle est occupée ou pas !
             
             Normalement, on est censé d'en être capable sans envoyer des messages (d'après ce qui a été dit en TD, et d'ailleurs,
             on ne peut pas envoyer un message à un Golem déjà). 
             
             Comment on connaît le résultat de l'action move()? A regarder!
      
      TODO/Idées : Une fois l'agent a fini, faut-il mettre en place le flood pour propager la carte compléte au maximum? Ou bien,
                  faut-il que les agents se retrouvent quelque part pour se dire qu'ils on finis?
                  
     - communication pour échanger des cartes
     
     Pour l'instant, on a des behaviours pour envoyer et recevoir un message
     
     TODO : Définir le protocole de communication entre les agents si ils veulent échanger leurs cartes. 
     
     TODO : Gérer pour chaque agent la structure dans laquelle on va retenir ce qu'on a déjà envoyé à qui... pour ne pas envoyer
            toujours le graphe complet.
     
     TODO : Définir le FSMBehaviour (machine à états) - pour le moment, réfléchir sur les différentes possibilités
     
     TODO/Idées : On apprends d'abord le noeud courrant (dans le behavoir SendGraph? Dans un autre? ) avant l'envoyer, ou pas?
                  On fais quoi si l'agent ne réponds pas? On attends? On s'en fiche?
  
  ------------------------------------------------------------------------------------------------------------------------------
  SEMAINE 5 : COORDINATION
  
  TODO : Envisager toutes les problèmes possibles qu'on peut rencontrer, et les solutions possibles (priorités de passage,
         comment traiter le Golem, ...)
  
  A LA LIMITE : Partage des zones.
  
                
                                
